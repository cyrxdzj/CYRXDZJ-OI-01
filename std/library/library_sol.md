## 内心深处的图书馆 题解

### 本题难点与坑点

以下是本题主要考查以下难点与坑点。

该列表仅用于显示出题人安排部分分的思路，不影响评测结果。

#### 快速计算区间

内容：本题 $n$ 值较大，不允许一个个计算。

如何向选手出示难点：明确写明数据范围。

正解对策：分块。

部分分对策：莫队。

若仅完成部分分对策，至少扣除 $52$ 分。

若上述对策均未完成，可能导致程序运行超时，至少扣除 $80$ 分。

#### 快速维护贡献

内容：通过 $\log$ 级别的数据结构，快速查询每种头脑清醒度下的概率。

如何向选手出示难点：明确写明数据范围。

正解对策：树状数组或线段树。

若未完成正解对策，可能导致程序运行超时，至少扣除 $72$ 分。

#### 较大的值域

内容：头脑清醒度和难度值值域较大。

如何向选手出示难点：明确写明数据范围。

正解对策：树状数组：离散化；线段树：离散化或动态开点线段树。

若未完成正解对策，可能导致程序空间超限，至少扣除 $56$ 分。

#### 概率为 0

内容：在部分头脑清醒度下，不可能读懂全部翻开的书页。但 $0$ 没有逆元，无法正常退回贡献。

如何向选手出示难点：提供大样例。

正解对策：封装特制数结构体，记录乘 $0$ 的次数。

若未完成正解对策，可能导致程序持续输出 $0$，至少扣除 $52$ 分或 $40$ 分（第5,7,9号测试点不使用莫队可规避）。

具有此性质的测试点：5,7,9,15~17,19~25，样例2,样例4,样例5。

#### 相同难度的书页

内容：使用线段树维护贡献时，部分书页难度相同，若未考虑到，进行区间修改时会导致左端点大于右端点。

如何向选手出示难点：提供大样例。

正解对策：合并这两页。

若未完成正解对策，可能导致程序运行时错误，至少扣除 $40$ 分。

具有此性质的测试点：9,16~17,19~25，样例3,样例4,样例5。

### Case 1~3

多个独立事件同时成立的概率，是这些独立事件各自单独成立的事件的积。

而针对每一本书，收到头脑清醒度之后，将所有难度值小于等于这个数的书页的概率加起来，就是能看懂这本书的概率。

这个思路明确后，我们就可以开始写出暴力代码了。

本部分分的代码为 `library_sol1.cpp` 和 `library_sol4.cpp`，其中后者预处理了前缀和，效率应该更高。

### 更高效地处理头脑清醒度和难度值之间的关系

可以很显然地发现，头脑清醒度和难度值的具体大小是不重要的，相对大小才是重要的。这让我们很容易地想到离散化。

而我们发现，假设有这么一本书，有难度值分别为 $1$，$3$，$6$ 的 $3$ 页，那么，头脑清醒度为 $3$  到 $5$ 之间阅读，是没有区别的。

所以，我们想到了使用线段树之类的带 $log$ 的数据结构，维护区间乘、单点查询，这样，每当有一本新书，就花费 $O(c\log V)$ 的时间复杂度将这本书送入线段树。查询时单点查询即可。

### Case 4~9

莫队。

需要注意，这个测试点使用莫队其实有一定的概率卡不过去，请注意优化常数。

本部分分的代码为 `library_sol2.cpp`。

### 除 0

虽然数据范围是保证了每一页被翻到的概率不为零，但是可没有保证在某个头脑清醒度下看懂一本书的概率不为零。

但书本是会更新的。无论是莫队的部分分做法，还是分块的正解，都免不了将某本书从线段树上取下，再换上新的一本书。

在取下这本书的过程，会除以原来这本书在某个头脑清醒度下贡献的概率，当这个概率为 $0$ 时就会出问题了。

解决这个问题的方案是定义特制数结构体，记录乘 $0$ 的次数，然后除 $0$ 时减掉这个次数即可。输出答案时，先判断乘 $0$ 多少次，再选择输出 $0$ 或原数据。

```cpp
struct Num	//特制数结构体
{
	long long data;	//原数据
	int cnt0;		//乘零次数
	Num()	//初始化
	{
		data=1;
		cnt0=0;
	}
	Num(long long v)
	{
		if(v==0)
		{
			data=1;
			cnt0=1;
		}
		else
		{
			data=v;
			cnt0=0;
		}
	}
	Num(long long v,int c)
	{
		data=v;
		cnt0=c;
	}
	operator long long()	//转long long
	{
		if(cnt0>0)
		{
			return 0;
		}
		else
		{
			return data;
		}
	}
};
Num operator *(Num a,Num b)	//自定义运算符
{
	return (Num){a.data*b.data%MOD,a.cnt0+b.cnt0};
}
Num operator /(Num a,Num b)
{
	return (Num){a.data*qpow(b.data,MOD-2)%MOD,a.cnt0-b.cnt0};
}
```



### 版权信息

题解：[广州市铁一中学 邓子君](https://www.luogu.com.cn/user/387836)

本题改编自广州市赛 2024 D2T4，是原题的加强版。

在 [CC-BY-NC 4.0](https://creativecommons.org/licenses/by-nc/4.0/legalcode.zh-hans) 协议下共享。
